# Game Agent Framework

A modular, extensible Python framework for building AI game agents that connect to game servers via WebSocket. Designed for Wordle and other word/puzzle games.

## ğŸ¯ Features

- **Modular Architecture**: Base class handles connection, messaging, and lifecycle
- **Easy Extension**: Create new game agents by inheriting and implementing 2 methods
- **Rich State Management**: Comprehensive enums for game states, commands, and results
- **Built-in Statistics**: Track wins, losses, guesses, and performance metrics
- **Reconnection Logic**: Automatic retry with configurable attempts and delays
- **OpenAI Integration**: Ready-to-use AI-powered guessing with structured outputs
- **Type Safety**: Full type hints and Pydantic models for data validation
- **Lifecycle Hooks**: Override methods to customize behavior at key moments

## ğŸ“‹ Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Architecture](#architecture)
- [Creating Your Own Agent](#creating-your-own-agent)
- [Examples](#examples)
- [Configuration](#configuration)
- [Advanced Usage](#advanced-usage)

## ğŸš€ Installation

### Requirements

```bash
pip install websockets openai python-dotenv pydantic
```

### Environment Setup

Create a `.env` file in your project root:

```env
OPENAI_API_KEY=your_api_key_here
```

## âš¡ Quick Start

### Using the Wordle Agent

```python
from wordle_agent_example import WordleAgent
from game_agent_framework import GameConfig, AgentRunner

# Configure connection
config = GameConfig(
    ws_url="ws://localhost:2025",
    connect_timeout=10,
    recv_timeout=2,
    keep_alive=True,
)

# Create and run agent
agent = WordleAgent(config=config, use_ai=True)
AgentRunner.run_agent(agent)
```

## ğŸ—ï¸ Architecture

### Core Components

#### 1. **BaseGameAgent** (Abstract Base Class)

The foundation for all game agents. Handles:
- WebSocket connection management
- Message parsing and routing
- Game lifecycle (start, play, result, end)
- Statistics tracking
- Error handling and reconnection

#### 2. **Enums** (Type Safety)

```python
GameType       # WORDLE, CUSTOM
MessageType    # GAME_START, GAME_RESULT, COMMAND, etc.
GameCommand    # GUESS, SOLVE, HINT
GameResult     # WIN, LOSS, TIMEOUT, ERROR
AgentState     # IDLE, CONNECTING, PLAYING, etc.
FeedbackType   # CORRECT, PRESENT, ABSENT (for Wordle)
```

#### 3. **Data Classes** (Structured Data)

```python
GameConfig      # Connection and behavior configuration
ParsedMessage   # Standardized message from server
GameStats       # Performance metrics and statistics
```

#### 4. **AgentRunner** (Execution Manager)

Manages agent lifecycle and provides clean execution interface.

## ğŸ¨ Creating Your Own Agent

### Minimum Implementation

To create a new agent, inherit from `BaseGameAgent` and implement 2 required methods:

```python
from game_agent_framework import BaseGameAgent, ParsedMessage, GameConfig, GameType
from typing import Optional, Dict, Any

class MyCustomAgent(BaseGameAgent):
    def __init__(self, config: GameConfig):
        super().__init__(config, GameType.CUSTOM)
    
    async def make_move(self, parsed: ParsedMessage) -> Optional[str]:
        """
        Generate your next move/guess based on game state.
        
        Args:
            parsed: Current game state with all available information
            
        Returns:
            Your move as a string, or None if no move possible
        """
        # Your game logic here
        length = parsed.word_length or 5
        return "hello"[:length]
    
    def build_response(self, parsed: ParsedMessage, move: Optional[str]) -> Optional[Dict[str, Any]]:
        """
        Build the JSON response to send to the server.
        
        Args:
            parsed: Current game state
            move: The move generated by make_move()
            
        Returns:
            Dictionary to be serialized as JSON response
        """
        if not move or not parsed.match_id:
            return None
        
        return {
            "matchId": parsed.match_id,
            "gameId": parsed.game_id,
            "otp": parsed.otp,
            "guess": move,
        }
```

### Optional Lifecycle Hooks

Override these methods to customize behavior:

```python
def on_game_start(self, parsed: ParsedMessage):
    """Called when a new game begins"""
    pass

def on_game_result(self, parsed: ParsedMessage):
    """Called when game ends with result"""
    pass

def on_acknowledgement(self, parsed: ParsedMessage):
    """Called when server acknowledges your move"""
    pass

def on_error(self, parsed: ParsedMessage):
    """Called when server sends error"""
    pass

def on_connected(self):
    """Called when WebSocket connection established"""
    pass

def on_disconnected(self):
    """Called when connection closes"""
    pass
```

## ğŸ“š Examples

### Example 1: Simple Alphabet Agent

```python
class AlphabetAgent(BaseGameAgent):
    """Guesses using sequential alphabet letters"""
    
    def __init__(self, config: GameConfig):
        super().__init__(config, GameType.WORDLE)
        self.alphabet = "abcdefghijklmnopqrstuvwxyz"
    
    async def make_move(self, parsed: ParsedMessage) -> Optional[str]:
        length = parsed.word_length or 5
        return self.alphabet[:length]
    
    def build_response(self, parsed: ParsedMessage, move: Optional[str]) -> Optional[Dict[str, Any]]:
        if not move:
            return None
        return {
            "matchId": parsed.match_id,
            "gameId": parsed.game_id,
            "otp": parsed.otp,
            "guess": move,
        }
```

### Example 2: AI-Powered Agent with Context

```python
class SmartWordleAgent(BaseGameAgent):
    """Uses OpenAI with feedback history for smarter guessing"""
    
    def __init__(self, config: GameConfig):
        super().__init__(config, GameType.WORDLE)
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        self.history = []
    
    async def make_move(self, parsed: ParsedMessage) -> Optional[str]:
        # Build context from history
        context = self._build_context(parsed)
        
        # Ask AI
        response = self.client.chat.completions.create(
            model="gpt-5-nano",
            messages=[
                {"role": "system", "content": "You are a Wordle expert."},
                {"role": "user", "content": context}
            ]
        )
        
        guess = response.choices[0].message.content.strip().lower()
        self.history.append((guess, parsed.last_result))
        return guess
    
    def _build_context(self, parsed: ParsedMessage) -> str:
        context = f"Word length: {parsed.word_length}\n"
        context += f"Attempt: {parsed.current_attempt}\n"
        
        if self.history:
            context += "Previous guesses:\n"
            for guess, feedback in self.history:
                context += f"  {guess}: {feedback}\n"
        
        context += "What's your next guess?"
        return context
    
    def build_response(self, parsed: ParsedMessage, move: Optional[str]) -> Optional[Dict[str, Any]]:
        # ... standard response building ...
        pass
```


## âš™ï¸ Configuration

### GameConfig Options

```python
config = GameConfig(
    ws_url="ws://localhost:2025",        # WebSocket server URL
    connect_timeout=10,                   # Connection timeout (seconds)
    recv_timeout=2,                       # Message receive timeout (seconds)
    keep_alive=True,                      # Keep connection alive between games
    max_reconnect_attempts=3,             # Retry attempts on connection failure
    reconnect_delay=5,                    # Delay between reconnection attempts (seconds)
)
```

### Agent Configuration

Each agent can have its own configuration options:

```python
agent = WordleAgent(
    config=config,
    ai_model="gpt-5-nano",              # OpenAI model to use
    use_structured_output=True,           # Use structured JSON responses
    use_ai=True,                          # Enable/disable AI features
)
```

## ğŸ”§ Advanced Usage

### Custom Message Parsing

Override `parse_message` for custom message formats:

```python
def parse_message(self, msg: str) -> Optional[ParsedMessage]:
    parsed = super().parse_message(msg)
    if parsed:
        # Add custom parsing logic
        parsed.metadata["custom_field"] = self._extract_custom_field(msg)
    return parsed
```

## ğŸ“Š Statistics & Monitoring

Access statistics at any time:

```python
agent = WordleAgent(config)
# ... run games ...

print(f"Games played: {agent.stats.games_played}")
print(f"Win rate: {agent.stats.games_won / agent.stats.games_played * 100:.1f}%")
print(f"Avg guesses: {agent.stats.total_guesses / agent.stats.games_played:.1f}")
```

Statistics are automatically printed when the agent disconnects.


## ğŸ® Supported Games

- âœ… **Wordle**: Word guessing with letter position feedback
- ğŸ”§ **Custom**: Extend for any game with similar mechanics

---

**Happy Gaming! ğŸ²**
